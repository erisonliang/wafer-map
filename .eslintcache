[{"E:\\Programming\\common\\wafer-map\\src\\index.js":"1","E:\\Programming\\common\\wafer-map\\src\\App.js":"2","E:\\Programming\\common\\wafer-map\\src\\wafermap\\index.js":"3","E:\\Programming\\common\\wafer-map\\src\\wafermap\\styles.js":"4","E:\\Programming\\common\\wafer-map\\src\\waferlist\\index.js":"5"},{"size":197,"mtime":1608369316018,"results":"6","hashOfConfig":"7"},{"size":166,"mtime":1608369732929,"results":"8","hashOfConfig":"7"},{"size":3905,"mtime":1608368983078,"results":"9","hashOfConfig":"7"},{"size":364,"mtime":1608365061798,"results":"10","hashOfConfig":"7"},{"size":527,"mtime":1608369733010,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1bp5l1g",{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"16","messages":"17","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"18","usedDeprecatedRules":"19"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"E:\\Programming\\common\\wafer-map\\src\\index.js",[],"E:\\Programming\\common\\wafer-map\\src\\App.js",[],"E:\\Programming\\common\\wafer-map\\src\\wafermap\\index.js",["24"],"import * as PIXI from \"pixi.js\";\r\nimport { useStyles } from \"./styles\";\r\nimport React, { useRef, useEffect } from \"react\";\r\nimport ZoomInIcon from \"@material-ui/icons/ZoomIn\";\r\nimport ZoomOutIcon from \"@material-ui/icons/ZoomOut\";\r\n\r\nconst WaferMap = (props) => {\r\n  const rootRef = useRef(null);\r\n  const classes = useStyles();\r\n  const { width, height } = props;\r\n\r\n  let scale = 1;\r\n  let app = null;\r\n  let currentStagePos = null;\r\n  let scaleMultiplier = 0.25;\r\n\r\n  const chipWidth = 0.5;\r\n  const chipHeight = 0.5;\r\n  const chipGap = 0.25;\r\n  const chipCount = 300;\r\n\r\n  const draw = (scale) => {\r\n    const graphics = new PIXI.Graphics();\r\n    graphics.interactive = true;\r\n\r\n    for (let y = 0; y < chipCount; y++) {\r\n      for (let x = 0; x < chipCount; x++) {\r\n        const dx = x * chipWidth + x * chipGap;\r\n        const dy = y * chipHeight + y * chipGap;\r\n        graphics.beginFill(0xde3249);\r\n        graphics.drawRect(dx, dy, chipWidth, chipHeight);\r\n        graphics.endFill();\r\n      }\r\n    }\r\n\r\n    graphics.x = width / 2 - graphics.width / 2;\r\n    graphics.y = height / 2 - graphics.height / 2;\r\n    app.stage.addChild(graphics);\r\n    app.stage.scale.x = scale;\r\n    app.stage.scale.y = scale;\r\n  };\r\n\r\n  /*const app = useMemo(\r\n    () =>\r\n      new PIXI.Application({\r\n        width: width,\r\n        height: height,\r\n        antialias: true,\r\n        transparent: true,\r\n        resolution: window.devicePixelRatio || 1,\r\n      }),\r\n    [width, height]\r\n  );*/\r\n\r\n  useEffect(() => {\r\n    app = new PIXI.Application({\r\n      width: width,\r\n      height: height,\r\n      antialias: true,\r\n      transparent: true,\r\n      resolution: window.devicePixelRatio || 1,\r\n    });\r\n    rootRef.current.appendChild(app.view);\r\n    draw(scale);\r\n\r\n    return () => {\r\n      app.destroy(app.view);\r\n    };\r\n  }, []);\r\n\r\n  const onMinusClick = (e) => {\r\n    scale *= scaleMultiplier;\r\n    draw(scale);\r\n  };\r\n\r\n  const onPlusClick = (e) => {\r\n    scale /= scaleMultiplier;\r\n    draw(scale);\r\n  };\r\n\r\n  const onMouseDown = (e) => {\r\n    currentStagePos = { x: e.nativeEvent.offsetX, y: e.nativeEvent.offsetY };\r\n  };\r\n\r\n  const onMouseUp = (e) => {\r\n    currentStagePos = null;\r\n  };\r\n\r\n  const onMouseMove = (e) => {\r\n    if (currentStagePos) {\r\n      const element = e.nativeEvent;\r\n      app.stage.x += element.offsetX - currentStagePos.x;\r\n      app.stage.y += element.offsetY - currentStagePos.y;\r\n      currentStagePos = { x: element.offsetX, y: element.offsetY };\r\n    }\r\n  };\r\n\r\n  const zoom = (delta, x, y) => {\r\n    const stage = app.stage;\r\n    const scaleOffset = delta > 0 ? 0.5 : 2;\r\n\r\n    const stagePos = {\r\n      x: (x - stage.x) / stage.scale.x,\r\n      y: (y - stage.y) / stage.scale.y,\r\n    };\r\n    const newScale = {\r\n      x: stage.scale.x * scaleOffset,\r\n      y: stage.scale.y * scaleOffset,\r\n    };\r\n    const newScreenPos = {\r\n      x: stagePos.x * newScale.x + stage.x,\r\n      y: stagePos.y * newScale.y + stage.y,\r\n    };\r\n\r\n    stage.x -= newScreenPos.x - x;\r\n    stage.y -= newScreenPos.y - y;\r\n    stage.scale.x = newScale.x;\r\n    stage.scale.y = newScale.y;\r\n  };\r\n\r\n  const onWheel = (e) => {\r\n    zoom(e.deltaY, e.nativeEvent.offsetX, e.nativeEvent.offsetY);\r\n  };\r\n\r\n  return (\r\n    <div className={classes.waferRoot} style={{ width: width, height: height }}>\r\n      <div className={classes.controlHolder}>\r\n        <div>\r\n          <button onClick={onMinusClick}>\r\n            <ZoomOutIcon fontSize=\"small\" />\r\n          </button>\r\n        </div>\r\n        <div>\r\n          <button onClick={onPlusClick}>\r\n            <ZoomInIcon fontSize=\"small\" />\r\n          </button>\r\n        </div>\r\n      </div>\r\n      <div\r\n        ref={rootRef}\r\n        className={classes.canvasRoot}\r\n        onWheel={onWheel}\r\n        onMouseDown={onMouseDown}\r\n        onMouseUp={onMouseUp}\r\n        onMouseMove={onMouseMove}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default WaferMap;\r\n",["25","26"],"E:\\Programming\\common\\wafer-map\\src\\wafermap\\styles.js",[],"E:\\Programming\\common\\wafer-map\\src\\waferlist\\index.js",[],{"ruleId":"27","severity":1,"message":"28","line":56,"column":11,"nodeType":"29","endLine":62,"endColumn":7},{"ruleId":"30","replacedBy":"31"},{"ruleId":"32","replacedBy":"33"},"react-hooks/exhaustive-deps","Assignments to the 'app' variable from inside React Hook useEffect will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside useEffect.","NewExpression","no-native-reassign",["34"],"no-negated-in-lhs",["35"],"no-global-assign","no-unsafe-negation"]